Hunting for Open Redirects:
--------------------------------

	1. Search for redirect URL parameters. These might be vulnerable to parameter-based open redirect.
	2. Search for pages that perform referer-based redirects. These are candidates for a referer-based open redirect.
	3. Test the pages and parameters you’ve found for open redirects.
	4. If the server blocks the open redirect, try the protection bypass techniques mentioned in this chapter.
	5. Brainstorm ways of using the open redirect in your other bug chains!

	
	Step 1: Look for Redirect Parameters:
	-----------------------------------------


		https://example.com/login?redirect=https://example.com/dashboard
		https://example.com/login?redir=https://example.com/dashboard
		https://example.com/login?next=https://example.com/dashboard
		https://example.com/login?next=/dashboard
		inurl:%3Dhttp site:example.com


		To prevent open redirects, the server needs to make sure it doesn’t redirect users to malicious locations. Sites often implement URL validators to ensure that the user-provided redirect URL points to a legitimate location.


		Note that not all redirect parameters have straightforward names like redirect or redir. For example, I’ve seen redirect parameters named RelayState, next, u, n, and forward. You should record all parameters that seem to be used for redirect, regardless of their parameter names


		In addition, take note of the pages that don’t contain redirect parameters in their URLs but still automatically redirect their users. These pages are candidates for referer-based open redirects. To find these pages, you can keep an eye out for 3XX response codes like 301 and 302. These response codes indicate a redirect



	Step 2: Use Google Dorks to Find Additional Redirect Parameters:
	-------------------------------------------------------------------

		look for pages that contain URLs in their URL parameters, making use of %3D, the URL-encoded version of the equal sign (=). By adding %3D in your search term, you can search for terms like =http and =https, which are indicators of URLs in a parameter. The following searches for URL parameters that contain absolute URLs: inurl:%3Dhttp site:example.com
		This search term might find the following pages:
			https://example.com/login?next=https://example.com/dashboard
			https://example.com/login?u=http://example.com/settings
			so here we know that the redirect parameters are next & u

		Also try using %2F, the URL-encoded version of the slash (/). The following search term searches URLs that contain =/, and therefore returns URL parameters that contain relative URLs: inurl:%3D%2F site:example.com
		This search term will find URLs such as this one:
			https://example.com/login?n=/dashboard
			so here we know that the redirect parameter is u

		Alternatively, you can search for the names of common URL redirect parameters. Here are a few search terms that will likely reveal parameters used for a redirect:
			inurl:redir site:example.com
			inurl:redirect site:example.com
			inurl:redirecturi site:example.com
			inurl:redirect_uri site:example.com
			inurl:redirecturl site:example.com
			inurl:redirect_uri site:example.com
			inurl:return site:example.com
			inurl:returnurl site:example.com
			inurl:relaystate site:example.com
			inurl:forward site:example.com
			inurl:forwardurl site:example.com
			inurl:forward_url site:example.com
			inurl:url site:example.com
			inurl:uri site:example.com
			inurl:dest site:example.com
			inurl:destination site:example.com
			inurl:next site:example.com

		These search terms will find URLs such as the following:
			https://example.com/logout?dest=/
			https://example.com/login?RelayState=https://example.com/home
			https://example.com/logout?forward=home
			https://example.com/login?return=home/settings




	Step 3: Test for Parameter-Based Open Redirects:
	---------------------------------------------------

		Next, pay attention to the functionality of each redirect parameter you’ve found and test each one for an open redirect. Insert a random hostname, or a hostname you own, into the redirect parameters; then see if the site automatically redirects to the site you specified:
			https://example.com/login?n=http://google.com
			https://example.com/login?n=http://attacker.com


		Some sites will redirect to the destination site immediately after you visit the URL, without any user interaction. But for a lot of pages, the redirect won’t happen until after a user action, like registration, login, or logout. In those cases, be sure to carry out the required user interactions before checking for the redirect.


	


	Step 4: Test for Referer-Based Open Redirects:
	-------------------------------------------------

		Finally, test for referer-based open redirects on any pages you found in step 1 that redirected users despite not containing a redirect URL parameter. To test for these, set up a page on a domain you own and host this HTML page:

			<html>
			 <a href="https://example.com/login">Click on this link!</a>
			</html>


		Replace the linked URL with the target page. Then reload and visit your HTML page. Click the link and see if you get redirected to your site automatically or after the required user interactions.



		
		Bypassing Open-Redirect Protection:
		-------------------------------------

			Using Browser Autocorrect:
			----------------------------

				First, you can use browser autocorrect features to construct alternative URLs that redirect offsite. Modern browsers often autocorrect URLs that don’t have the correct components, in order to correct mangled URLs caused by user typos. For example, Chrome will interpret all of these URLs as pointing to https://attacker.com:
					https:attacker.com
					https;attacker.com
					https:\/\/attacker.com
					https:/\/\attacker.com


				These quirks can help you bypass URL validation based on a blocklist. For example, if the validator rejects any redirect URL that contains the strings https:// or http://, you can use an alternative string, like https;, to achieve the same results.


				Most modern browsers also automatically correct backslashes (\) to forward slashes (/), meaning they’ll treat these URLs as the same:
					https:\\example.com
					https://example.com

				
				If the validator doesn’t recognize this behavior, the inconsistency could lead to bugs. For example, the following URL is potentially problematic:
					https://attacker.com\@example.com



			Exploiting Flawed Validator Logic:
			-------------------------------------

				Another way you can bypass the open-redirect validator is by exploiting loopholes in the validator’s logic. For example, as a common defense against open redirects, the URL validator often checks if the redirect URL starts with, contains, or ends with the site’s domain name. You can bypass this type of protection by creating a subdomain or directory with the target’s domain name:
					https://example.com/login?redir=http://example.com.attacker.com
					https://example.com/login?redir=http://attacker.com/example.com


				To prevent attacks like these from succeeding, the validator might accept only URLs that both start and end with a domain listed on the allowlist. However, it’s possible to construct a URL that satisfies both of these rules. Take a look at this one:
					https://example.com/login?redir=https://example.com.attacker.com/example.com

				This URL redirects to attacker.com, despite beginning and ending with the target domain. The browser will interpret the first example.com as the subdomain name and the second one as the filepath. Or you could use the at symbol (@) to make the first example.com the username portion of the URL:
					https://example.com/login?redir=https://example.com@attacker.com/example.com




			Using Data URLs:
			-------------------

				data:MEDIA_TYPE[;base64],DATA
				data:text/plain,hello!
				data:text/plain;base64,aGVsbG8h
				data:text/html;base64,PHNjcmlwdD5sb2NhdGlvbj0iaHR0cHM6Ly9leGFtcGxlLmNvbSI8L3NjcmlwdD4=
				<script>location="https://example.com"</script>
				https://example.com/login?redir=data:text/html;base64,PHNjcmlwdD5sb2NhdGlvbj0iaHR0cHM6Ly9leGFtcGxlLmNvbSI8L3NjcmlwdD4=



			Exploiting URL Decoding:
			---------------------------

				When validators validate URLs, or when browsers redirect users, they have to first find out what is contained in the URL by decoding any characters that are URL encoded

				If there is any inconsistency between how the validator and browsers decode URLs, you could exploit that to your advantage.




			Double Encoding:
			--------------------
			if the validator doesn’t double-decode URLs, but the browser does, you can use a payload like this one:
				https://attacker.com%252f@example.com
			The validator would see example.com as the hostname. But the browser would redirect to attacker.com, because @example.com becomes the path portion of the URL, like this:
				https://attacker.com/@example.com




